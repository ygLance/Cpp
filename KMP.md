# KMP算法

- 当pattern的第j个字符匹配失败时,也说明了他前面的字符都匹配成功了
- 我们在BF算法中为了防止一次失败的匹配毁了本应成功的匹配,对string进行了回溯
- 而现在,根据前匹配成功这一条件把成功匹配的消息传达给pat的开头元素......

### next数组
* 除当前字符外的最长相同前缀后缀(又,前缀必然是最前面的,故也为对应相同前缀char的index)
* 从头遍历dp,每一次小的遍历中k都会回溯为-1
* 计算next数组的那 "致命回首"( k=next(k)),是一种局部的防止原本成功的匹配失败,即无法找大的公共串,按照"现在失败即之前成功"原理,通过成功的那部分,找一个小串
* 这一步,就是用前面的一个小串做pat和大pat做匹配,已经用上了next数组的功能(有点递归的意思)
* 前后缀不是对称排列的,是同一个方向排列的
  
```
void Getnext(int next[],String t)
{
   int j=0,k=-1;
   next[0]=-1;
   while(j<t.length-1)
   {
      if(k == -1 || t[j] == t[k])
      {
         j++;k++;
         next[j] = k;
      }
      else k = next[k];//此语句是这段代码最反人类的地方，如果你一下子就能看懂，那么请允许我称呼你一声大神！
   }
}
```
